name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

# Ajouter les permissions nécessaires
permissions:
  contents: write  # Nécessaire pour créer des tags
  packages: write  # Optionnel, pour les packages

env:
  DOCKERHUB_REPOSITORY: 'aussie_weather_flow'  # Corrigé le nom du repo

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements-ga.txt
          
      - name: Run Unit Tests
        run: |
          pytest plugins/tests --maxfail=5 --disable-warnings

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}  # Utiliser le token GitHub

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Get next version
        id: version
        run: |
          # Fonction pour obtenir la dernière version d'une image
          get_latest_version() {
            local image_suffix=$1
            local repo="${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKERHUB_REPOSITORY }}"
            
            # Récupérer les tags via l'API Docker Hub
            local response=$(curl -s "https://registry.hub.docker.com/v2/repositories/${repo}/tags/?page_size=100")
            
            # Extraire les versions pour cette image spécifique
            local versions=$(echo "$response" | jq -r --arg suffix "$image_suffix" '.results[] | select(.name | contains($suffix)) | .name' | grep -E "${image_suffix}-[0-9]+\.[0-9]+" | sed "s/${image_suffix}-//" | sort -V)
            
            if [ -z "$versions" ]; then
              echo "0.0"
            else
              echo "$versions" | tail -1
            fi
          }
          
          # Obtenir la version la plus élevée parmi toutes les images
          declare -a IMAGE_SUFFIXES=("airflow-base" "fastapi" "mlflow-webserver" "frontend")
          HIGHEST_VERSION="0.0"
          
          for suffix in "${IMAGE_SUFFIXES[@]}"; do
            version=$(get_latest_version "$suffix")
            echo "Latest version for $suffix: $version"
            
            # Comparer les versions (simple comparaison numérique)
            if [ "$(printf '%s\n' "$HIGHEST_VERSION" "$version" | sort -V | tail -n1)" = "$version" ]; then
              HIGHEST_VERSION="$version"
            fi
          done
          
          echo "Highest existing version: $HIGHEST_VERSION"
          
          # Incrémenter la version
          if [ "$HIGHEST_VERSION" = "0.0" ]; then
            NEW_VERSION="0.1"
          else
            # Extraire major et minor
            MAJOR=$(echo "$HIGHEST_VERSION" | cut -d. -f1)
            MINOR=$(echo "$HIGHEST_VERSION" | cut -d. -f2)
            
            # Incrémenter la version mineure
            NEW_MINOR=$((MINOR + 1))
            NEW_VERSION="${MAJOR}.${NEW_MINOR}"
          fi
          
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Build Images
        run: |
          # Définir les images et leurs chemins
          declare -A IMAGE_PATHS=(
            ["mlops-meteo-airflow-base"]="./dockerfiles/airflow"
            ["mlops-meteo-fastapi"]="./dockerfiles/api"
            ["mlops-meteo-mlflow-webserver"]="./dockerfiles/mlflow"
            ["mlops-meteo-frontend"]="./dockerfiles/frontend"
          )
          
          # Construction de chaque image
          for IMAGE in "${!IMAGE_PATHS[@]}"; do
            BUILD_PATH="${IMAGE_PATHS[$IMAGE]}"
            echo "Building $IMAGE from $BUILD_PATH..."
            
            # Build de l'image
            docker build -t "$IMAGE" "$BUILD_PATH"
            
          done

      - name: Tag and Push Images
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          echo "Using version: $VERSION"
          
          for IMAGE in mlops-meteo-airflow-base mlops-meteo-fastapi mlops-meteo-mlflow-webserver mlops-meteo-frontend; do
            # Récupérer l'ID de l'image
            IMAGE_ID=$(docker images "$IMAGE" --format "{{.ID}}" | head -n 1)
            
            if [ -n "$IMAGE_ID" ]; then
              # Extraire le nom sans le préfixe
              IMAGE_NAME="${IMAGE##mlops-meteo-}"
              NEW_IMAGE="${{ secrets.DOCKERHUB_USERNAME }}/${{ env.DOCKERHUB_REPOSITORY }}:${IMAGE_NAME}-${VERSION}"
              
              # Tag et push
              docker tag "$IMAGE_ID" "$NEW_IMAGE"
              docker push "$NEW_IMAGE"
              
              echo "Pushed $NEW_IMAGE"
            fi
          done

      - name: Create Git Tag
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a "v${VERSION}" -m "Release version ${VERSION}"
          git push origin "v${VERSION}"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
